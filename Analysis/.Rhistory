interaction_coef <- model_summary$tTable[interaction_term, "Value"]
interaction_se <- model_summary$tTable[interaction_term, "Std.Error"]
# Interpretation message
message("\n--- Interpretation ---")
if (!is.na(interaction_p)) {
if (interaction_p < 0.05) {
message("The interaction term is statistically significant (p < 0.05). It should likely be included in the model.")
} else if (interaction_p < 0.1) {
message("The interaction term is borderline significant (0.05 < p < 0.1). Consider including it if the effect size is meaningful.")
} else {
message("The interaction term is **not statistically significant (p > 0.1)**. Consider removing it from the model.")
}
} else {
message("The interaction term was not found in the model. Check variable names.")
}
# Check if effect size is meaningful
if (!is.na(interaction_coef)) {
if (abs(interaction_coef) < interaction_se * 2) {
message("The interaction effect is small relative to its standard error. The effect may not be practically meaningful.")
} else {
message("The interaction effect size appears meaningful.")
}
}
return(list(
model = model,
anova = anova_res,
AIC = aic_value,
interaction_p = interaction_p,
interaction_coef = interaction_coef,
interaction_se = interaction_se,
plots = list(p1, p2)
))
}
## Check Interactions
interaction_results <- list(
"mean_BT_smooth ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_BT_smooth", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_heartrate", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_BT_smooth ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_BT_smooth", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_heartrate", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_activity_percent ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_activity_percent", "phase_mean_CT", "season_year", random_effect = ~1 | ID_phase)
)
# Function to check interactions
test_interaction <- function(data, response, predictor, moderator, random_effect = NULL) {
message(sprintf("Testing interaction: %s ~ %s * %s", response, predictor, moderator))
# Boxplot to check overlap
p1 <- ggplot(data, aes_string(x = moderator, y = predictor)) +
geom_boxplot() +
theme_minimal() +
labs(title = sprintf("Boxplot of %s by %s", predictor, moderator))
print(p1)
# Scatter plot with interaction
p2 <- ggplot(data, aes_string(x = predictor, y = response, color = moderator)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, fullrange = TRUE) +
theme_minimal() +
labs(title = sprintf("Interaction of %s and %s on %s", predictor, moderator, response))
print(p2)
# Ensure correct correlation grouping
if ("ID_phase" %in% colnames(data)) {
correlation_structure <- corGaus(form = ~ as.numeric(day_season) | ID_phase, nugget = TRUE)
} else {
correlation_structure <- corGaus(form = ~ as.numeric(day_season) | ID_phase, nugget = TRUE)
}
# Fit model
formula <- as.formula(sprintf("%s ~ %s * %s", response, predictor, moderator))
if (!is.null(random_effect)) {
model <- tryCatch(
lme(
formula,
random = random_effect,
method = "ML",
data = data,
correlation = correlation_structure,
na.action = na.exclude
),
error = function(e) {
message("Error fitting model. Trying without correlation structure...")
lme(
formula,
random = random_effect,
method = "ML",
data = data,
na.action = na.exclude
)
}
)
} else {
model <- lm(formula, data = data)
}
# Model summary
model_summary <- summary(model)
print(model_summary)
# ANOVA
anova_res <- anova(model)
print(anova_res)
# Extract p-value for interaction term
interaction_term <- paste0(predictor, ":", moderator)
if (interaction_term %in% rownames(anova_res)) {
interaction_p <- anova_res[interaction_term, "p-value"]
} else {
interaction_p <- NA
}
# AIC
aic_value <- AIC(model)
message(sprintf("AIC: %.2f", aic_value))
# Extract interaction coefficient
interaction_coef <- model_summary$tTable[interaction_term, "Value"]
interaction_se <- model_summary$tTable[interaction_term, "Std.Error"]
# Interpretation message
message("\n--- Interpretation ---")
if (!is.na(interaction_p)) {
if (interaction_p < 0.05) {
message("The interaction term is statistically significant (p < 0.05). It should likely be included in the model.")
} else if (interaction_p < 0.1) {
message("The interaction term is borderline significant (0.05 < p < 0.1). Consider including it if the effect size is meaningful.")
} else {
message("The interaction term is **not statistically significant (p > 0.1)**. Consider removing it from the model.")
}
} else {
message("The interaction term was not found in the model. Check variable names.")
}
# Check if effect size is meaningful
if (!is.na(interaction_coef)) {
if (abs(interaction_coef) < interaction_se * 2) {
message("The interaction effect is small relative to its standard error. The effect may not be practically meaningful.")
} else {
message("The interaction effect size appears meaningful.")
}
}
return(list(
model = model,
anova = anova_res,
AIC = aic_value,
interaction_p = interaction_p,
interaction_coef = interaction_coef,
interaction_se = interaction_se,
plots = list(p1, p2)
))
}
##################################################################################
############################ OVP analysis: summer day ############################
##################################################################################
rm(list = ls()); gc() # make sure environment is clean
export = TRUE # Export?
# Activate package libraries
library(patchwork)
library(feather)
library(mgcv)
library(car)
library(ggeffects)
library(MASS)
library(emmeans)
library(gamm4)
library(effects)
library(stats)
library(lme4)
library(lmerTest)
library(performance)
library(tidyverse)
# Set WD and get source code functions
setwd("/Users/serpent/Documents/VHL/OVP/Code/Analysis")
source("SEM (MWE)/functions.R")
# Read data
dat <- read_csv("/Users/serpent/Documents/VHL/OVP/Data/ovp_data_10_12_24.csv")
# Get summer day subset
summer <- dat %>% prep_ovp("Summer", "day") # ok
# ----- Exploration -----
colSums(is.na(summer)) # no missing values
# Check response variables
plot1 <- check_response_var(summer, "mean_BT_smooth", "Mean BT Smooth")
plot2 <- check_response_var(summer, "mean_activity_percent", "Mean Activity Percent")
plot3 <- check_response_var(summer, "mean_heartrate", "Mean Heartrate")
(plot1 | plot2 | plot3)
rm(plot1, plot2, plot3) # clean environment
## Note: we disregard WCF (wind chill factor) due to high collinearity
response_vars <- c("mean_BT_smooth", "mean_heartrate", "mean_activity_percent")
predictor_vars <- c("phase_mean_CT", "day_season", "weight")
## Check linearity
results <- explore_relationships(summer, response_vars, predictor_vars, random_effect = list(ID = ~1))
## Check autocorrelation
autocorr_BT <- assess_autocorrelation(summer, "mean_BT_smooth", "ID", "season_year", lags = 40)
autocorr_HR <- assess_autocorrelation(summer, "mean_heartrate", "ID", "season_year", lags = 40)
autocorr_AC <- assess_autocorrelation(summer, "mean_activity_percent", "ID", "season_year", lags = 40)
## Check random effect
random_factor_BT <- explore_random_factor(summer, "mean_BT_smooth", "ID")
random_factor_HR <- explore_random_factor(summer, "mean_heartrate", "ID")
random_factor_AC <- explore_random_factor(summer, "mean_activity_percent", "ID")
## Check Interactions
interaction_results <- list(
"mean_BT_smooth ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_BT_smooth", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_heartrate", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_BT_smooth ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_BT_smooth", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_heartrate", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_activity_percent ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_activity_percent", "phase_mean_CT", "season_year", random_effect = ~1 | ID_phase)
)
# Function to check interactions
test_interaction <- function(data, response, predictor, moderator, random_effect = NULL) {
message(sprintf("Testing interaction: %s ~ %s * %s", response, predictor, moderator))
# Boxplot to check overlap
p1 <- ggplot(data, aes_string(x = moderator, y = predictor)) +
geom_boxplot() +
theme_minimal() +
labs(title = sprintf("Boxplot of %s by %s", predictor, moderator))
print(p1)
# Scatter plot with interaction
p2 <- ggplot(data, aes_string(x = predictor, y = response, color = moderator)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, fullrange = TRUE) +
theme_minimal() +
labs(title = sprintf("Interaction of %s and %s on %s", predictor, moderator, response))
print(p2)
# Ensure correct correlation grouping
if ("ID_phase" %in% colnames(data)) {
correlation_structure <- corGaus(form = ~ as.numeric(day_season) | ID_phase, nugget = TRUE)
} else {
correlation_structure <- corGaus(form = ~ as.numeric(day_season) | ID_phase, nugget = TRUE)
}
# Fit model
formula <- as.formula(sprintf("%s ~ %s * %s", response, predictor, moderator))
if (!is.null(random_effect)) {
model <- tryCatch(
lme(
formula,
random = random_effect,
method = "ML",
data = data,
correlation = correlation_structure,
na.action = na.exclude
),
error = function(e) {
message("Error fitting model. Trying without correlation structure...")
lme(
formula,
random = random_effect,
method = "ML",
data = data,
na.action = na.exclude
)
}
)
} else {
model <- lm(formula, data = data)
}
# Model summary
model_summary <- summary(model)
print(model_summary)
# ANOVA
anova_res <- anova(model)
print(anova_res)
# Extract p-value for interaction term
interaction_term <- paste0(predictor, ":", moderator)
if (interaction_term %in% rownames(anova_res)) {
interaction_p <- anova_res[interaction_term, "p-value"]
} else {
interaction_p <- NA
}
# AIC
aic_value <- AIC(model)
message(sprintf("AIC: %.2f", aic_value))
# Extract interaction coefficient
interaction_coef <- model_summary$tTable[interaction_term, "Value"]
interaction_se <- model_summary$tTable[interaction_term, "Std.Error"]
# Interpretation message
message("\n--- Interpretation ---")
if (!is.na(interaction_p)) {
if (interaction_p < 0.05) {
message("The interaction term is statistically significant (p < 0.05). It should likely be included in the model.")
} else if (interaction_p < 0.1) {
message("The interaction term is borderline significant (0.05 < p < 0.1). Consider including it if the effect size is meaningful.")
} else {
message("The interaction term is **not statistically significant (p > 0.1)**. Consider removing it from the model.")
}
} else {
message("The interaction term was not found in the model. Check variable names.")
}
# Check if effect size is meaningful
if (!is.na(interaction_coef)) {
if (abs(interaction_coef) < interaction_se * 2) {
message("The interaction effect is small relative to its standard error. The effect may not be practically meaningful.")
} else {
message("The interaction effect size appears meaningful.")
}
}
return(list(
model = model,
anova = anova_res,
AIC = aic_value,
interaction_p = interaction_p,
interaction_coef = interaction_coef,
interaction_se = interaction_se,
plots = list(p1, p2)
))
}
## Check Interactions
interaction_results <- list(
"mean_BT_smooth ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_BT_smooth", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_heartrate", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_BT_smooth ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_BT_smooth", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_heartrate", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_activity_percent ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_activity_percent", "phase_mean_CT", "season_year", random_effect = ~1 | ID_phase)
)
# Function to run interaction test
test_interaction <- function(data, response, predictor, moderator, random_effect = NULL) {
message(sprintf("Testing interaction: %s ~ %s * %s", response, predictor, moderator))
# Boxplot to check overlap
p1 <- ggplot(data, aes_string(x = moderator, y = predictor)) +
geom_boxplot() +
theme_minimal() +
labs(title = sprintf("Boxplot of %s by %s", predictor, moderator))
print(p1)
# Scatter plot with interaction
p2 <- ggplot(data, aes_string(x = predictor, y = response, color = moderator)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, fullrange = TRUE) +
theme_minimal() +
labs(title = sprintf("Interaction of %s and %s on %s", predictor, moderator, response))
print(p2)
# Ensure correct correlation grouping
if ("ID_phase" %in% colnames(data)) {
correlation_structure <- corGaus(form = ~ as.numeric(day_season) | ID_phase, nugget = TRUE)
} else {
correlation_structure <- corGaus(form = ~ as.numeric(day_season) | ID.per, nugget = TRUE)
}
# Fit model
formula <- as.formula(sprintf("%s ~ %s * %s", response, predictor, moderator))
use_lme <- !is.null(random_effect)  # Use lme if a random effect is provided
model <- tryCatch(
{
if (use_lme) {
lme(formula,
random = random_effect,
method = "ML",
data = data,
correlation = correlation_structure,
na.action = na.exclude)
} else {
lm(formula, data = data)
}
},
error = function(e) {
message("Error fitting model. Trying without correlation structure...")
if (use_lme) {
return(lme(formula, random = random_effect, method = "ML", data = data, na.action = na.exclude))
} else {
return(lm(formula, data = data))
}
}
)
# Model summary
model_summary <- summary(model)
print(model_summary)
# ANOVA
anova_res <- anova(model)
print(anova_res)
# Extract p-value for interaction term (handling name issues)
interaction_term <- paste0(predictor, ":", moderator)
interaction_p <- NA
# Check if interaction term exists in ANOVA output
if (interaction_term %in% rownames(anova_res)) {
interaction_p <- anova_res[interaction_term, "p-value"]
} else {
# Try alternative name formats for factors
interaction_term_alt <- grep(":", rownames(anova_res), value = TRUE)
if (length(interaction_term_alt) > 0) {
interaction_p <- anova_res[interaction_term_alt, "p-value"]
}
}
# AIC
aic_value <- AIC(model)
message(sprintf("AIC: %.2f", aic_value))
# Extract interaction coefficient, handling different model types
interaction_coef <- NA
interaction_se <- NA
if (use_lme) {
# For lme models, use tTable
coef_table <- model_summary$tTable
if (interaction_term %in% rownames(coef_table)) {
interaction_coef <- coef_table[interaction_term, "Value"]
interaction_se <- coef_table[interaction_term, "Std.Error"]
}
} else {
# For lm models, use coefficients
coef_table <- coef(model)
if (interaction_term %in% names(coef_table)) {
interaction_coef <- coef_table[interaction_term]
interaction_se <- summary(model)$coefficients[interaction_term, "Std. Error"]
}
}
# Interpretation message
message("\n--- Interpretation ---")
if (!is.na(interaction_p)) {
if (interaction_p < 0.05) {
message("✅ The interaction term is statistically significant (p < 0.05). It should likely be included in the model.")
} else if (interaction_p < 0.1) {
message("⚠️ The interaction term is borderline significant (0.05 < p < 0.1). Consider including it if the effect size is meaningful.")
} else {
message("❌ The interaction term is **not statistically significant (p > 0.1)**. Consider removing it from the model.")
}
} else {
message("❌ The interaction term was not found in the model. Check variable names.")
}
# Check if effect size is meaningful
if (!is.na(interaction_coef)) {
if (abs(interaction_coef) < interaction_se * 2) {
message("⚠️ The interaction effect is small relative to its standard error. The effect may not be practically meaningful.")
} else {
message("✅ The interaction effect size appears meaningful.")
}
}
return(list(
model = model,
anova = anova_res,
AIC = aic_value,
interaction_p = interaction_p,
interaction_coef = interaction_coef,
interaction_se = interaction_se,
plots = list(p1, p2)
))
}
## Check Interactions
interaction_results <- list(
"mean_BT_smooth ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_BT_smooth", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ mean_activity_percent * season_year" = test_interaction(summer, "mean_heartrate", "mean_activity_percent", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_BT_smooth ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_BT_smooth", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_heartrate ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_heartrate", "phase_mean_CT", "season_year", random_effect = ~1 + mean_activity_percent | ID_phase),
"mean_activity_percent ~ phase_mean_CT * season_year" = test_interaction(summer, "mean_activity_percent", "phase_mean_CT", "season_year", random_effect = ~1 | ID_phase)
)
View(summer)
# Get variable descriptives
descriptive_stats <- compute_descriptive_stats(summer, c("mean_BT_smooth", "mean_activity_percent", "mean_heartrate", "phase_mean_CT"))
# Function to compute descriptive statistics
compute_descriptive_stats <- function(data, variables) {
stats <- data.frame(
Variable = character(),
Min = numeric(),
Max = numeric(),
Mean = numeric(),
SD = numeric(),
CV_Percent = numeric(),
Q2_5 = numeric(),
Q97_5 = numeric(),
stringsAsFactors = FALSE
)
for (var in variables) {
if (var %in% colnames(data)) {
min_val <- min(data[[var]], na.rm = TRUE)
max_val <- max(data[[var]], na.rm = TRUE)
mean_val <- mean(data[[var]], na.rm = TRUE)
sd_val <- sd(data[[var]], na.rm = TRUE)
cv_val <- (sd_val / mean_val) * 100
quantiles <- quantile(data[[var]], probs = c(0.025, 0.975), na.rm = TRUE)
stats <- rbind(stats, data.frame(
Variable = var,
Min = round(min_val, 2),
Max = round(max_val, 2),
Mean = round(mean_val, 2),
SD = round(sd_val, 2),
CV_Percent = round(cv_val, 2),
Q2_5 = round(quantiles[1], 2),
Q97_5 = round(quantiles[2], 2)
))
} else {
message(sprintf("Warning: Variable '%s' not found in dataset.", var))
}
}
return(stats)
}
# Get variable descriptives
descriptive_stats <- compute_descriptive_stats(summer, c("mean_BT_smooth", "mean_activity_percent", "mean_heartrate", "phase_mean_CT"))
print(descriptive_stats)
View(descriptive_stats)
# Function to compute descriptive statistics
compute_descriptive_stats <- function(data, variables) {
stats <- data.frame(
Variable = character(),
Min = numeric(),
Max = numeric(),
Mean = numeric(),
SD = numeric(),
CV_Percent = numeric(),
Q2_5 = numeric(),
Q97_5 = numeric(),
stringsAsFactors = FALSE
)
for (var in variables) {
if (var %in% colnames(data)) {
min_val <- min(data[[var]], na.rm = TRUE)
max_val <- max(data[[var]], na.rm = TRUE)
mean_val <- mean(data[[var]], na.rm = TRUE)
sd_val <- sd(data[[var]], na.rm = TRUE)
cv_val <- (sd_val / mean_val) * 100
quantiles <- quantile(data[[var]], probs = c(0.025, 0.975), na.rm = TRUE)
stats <- rbind(stats, data.frame(
Variable = var,
Min = round(min_val, 2),
Max = round(max_val, 2),
Mean = round(mean_val, 2),
SD = round(sd_val, 2),
CV_Percent = round(cv_val, 2),
Q2_5 = round(quantiles[1], 2),
Q97_5 = round(quantiles[2], 2)
), make.row.names = FALSE)  # Ensure row names do not get inherited
} else {
message(sprintf("Warning: Variable '%s' not found in dataset.", var))
}
}
rownames(stats) <- NULL  # Explicitly reset row names
return(stats)
}
# Get variable descriptives
descriptive_stats <- compute_descriptive_stats(summer, c("mean_BT_smooth", "mean_activity_percent", "mean_heartrate", "phase_mean_CT"))
print(descriptive_stats)
